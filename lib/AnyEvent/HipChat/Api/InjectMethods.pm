package AnyEvent::HipChat::Api::InjectMethods;

# **************** ! W A R N I N G ! ************************ #
#  This class is AUTOGENERATED.                               #
#  DO NOT modify it by hand.                                  #
#  You should subclass or modify generate_api.pl if needed.   #
# *********************************************************** #

use strict;
use warnings;
use AnyEvent::HipChat::Utils qw/OK FAILED/;
use parent q/Exporter/;

our @EXPORT = qw/ add_member addon_ui_update create_global_action create_global_dialog
  create_global_external_page create_global_glance create_global_web_panel create_global_webhook
  create_integration_link create_room create_room_action create_room_dialog
  create_room_external_page create_room_glance create_room_web_panel create_room_webhook
  create_user create_webhook delete_global_action delete_global_dialog
  delete_global_external_page delete_global_glance delete_global_web_panel delete_global_webhook
  delete_group_avatar delete_integration_link delete_photo delete_room
  delete_room_action delete_room_dialog delete_room_external_page delete_room_glance
  delete_room_web_panel delete_room_webhook delete_session delete_user
  delete_webhook generate_token get_addon_capabilities_schema get_all_emoticons
  get_all_members get_all_participants get_all_rooms get_all_users
  get_all_webhooks get_auto_join_rooms get_capabilities get_emoticon
  get_global_action get_global_dialog get_global_external_page get_global_glance
  get_global_web_panel get_global_webhook get_group_avatar get_integration_installable_data
  get_photo get_privatechat_message get_room get_room_action
  get_room_dialog get_room_external_page get_room_glance get_room_message
  get_room_statistics get_room_web_panel get_room_webhook get_session
  get_webhook group_statistics invite_user invite_user_to_group
  invoke_integration_link private_message_user remove_member reply_to_message
  room_addon_ui_update send_message send_room_notification set_topic
  share_link_with_room share_link_with_user update_group_avatar update_photo
  update_room update_user user_addon_ui_update user_in_room_addon_ui_update
  view_group view_privatechat_history view_recent_privatechat_history view_recent_room_history
  view_room_history view_user /;

sub add_member {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'user_id not defined'), return } if not exists $args{user_id};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/member/%s", delete $args{room_id}, delete $args{user_id}),
        undef,
        \%args,
        $cb
    );
}

sub addon_ui_update {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'glance not defined'), return } if not exists $args{glance};
    $self->universal_req(
        POST => sprintf("/v2/addon/ui"),
        undef,
        \%args,
        $cb
    );
}

sub create_global_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'),      return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'target not defined'),   return } if not exists $args{target};
    do { $cb->(FAILED, undef, 'location not defined'), return } if not exists $args{location};
    do { $cb->(FAILED, undef, 'name not defined'),     return } if not exists $args{name};
    $self->universal_req(
        PUT => sprintf("/v2/extension/action/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_global_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'),   return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'),   return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'title not defined'), return } if not exists $args{title};
    $self->universal_req(
        PUT => sprintf("/v2/extension/dialog/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_global_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'), return } if not exists $args{url};
    $self->universal_req(
        PUT => sprintf("/v2/extension/externalPage/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_global_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'),  return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'icon not defined'), return } if not exists $args{icon};
    do { $cb->(FAILED, undef, 'name not defined'), return } if not exists $args{name};
    $self->universal_req(
        PUT => sprintf("/v2/extension/glance/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_global_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'),      return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'name not defined'),     return } if not exists $args{name};
    do { $cb->(FAILED, undef, 'url not defined'),      return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'location not defined'), return } if not exists $args{location};
    $self->universal_req(
        PUT => sprintf("/v2/extension/webPanel/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_global_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'),   return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'),   return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'event not defined'), return } if not exists $args{event};
    $self->universal_req(
        PUT => sprintf("/v2/extension/webhook/%s", $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_integration_link {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'target not defined'), return } if not exists $args{target};
    do { $cb->(FAILED, undef, 'ttl not defined'),    return } if not exists $args{ttl};
    $self->universal_req(
        POST => sprintf("/v2/addon/link"),
        undef,
        \%args,
        $cb
    );
}

sub create_room {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'name not defined'), return } if not exists $args{name};
    $self->universal_req(
        POST => sprintf("/v2/room"),
        undef,
        \%args,
        $cb
    );
}

sub create_room_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),  return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),      return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'target not defined'),   return } if not exists $args{target};
    do { $cb->(FAILED, undef, 'location not defined'), return } if not exists $args{location};
    do { $cb->(FAILED, undef, 'name not defined'),     return } if not exists $args{name};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/action/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_room_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'),     return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'title not defined'),   return } if not exists $args{title};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/dialog/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_room_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'),     return } if not exists $args{url};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/externalPage/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_room_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'icon not defined'),    return } if not exists $args{icon};
    do { $cb->(FAILED, undef, 'name not defined'),    return } if not exists $args{name};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/glance/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_room_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),  return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),      return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'name not defined'),     return } if not exists $args{name};
    do { $cb->(FAILED, undef, 'url not defined'),      return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'location not defined'), return } if not exists $args{location};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/webPanel/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_room_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    do { $cb->(FAILED, undef, 'url not defined'),     return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'event not defined'),   return } if not exists $args{event};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/extension/webhook/%s", delete $args{room_id}, $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub create_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'name not defined'),  return } if not exists $args{name};
    do { $cb->(FAILED, undef, 'email not defined'), return } if not exists $args{email};
    $self->universal_req(
        POST => sprintf("/v2/user"),
        undef,
        \%args,
        $cb
    );
}

sub create_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'url not defined'),     return } if not exists $args{url};
    do { $cb->(FAILED, undef, 'event not defined'),   return } if not exists $args{event};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/webhook", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/action/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/dialog/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/externalPage/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/glance/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/webPanel/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_global_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/extension/webhook/%s", delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_group_avatar {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'group_id not defined'), return } if not exists $args{group_id};
    $self->universal_req(
        DELETE => sprintf("/v2/group/%s/avatar", delete $args{group_id}),
        undef,
        \%args,
        $cb
    );
}

sub delete_integration_link {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'token not defined'), return } if not exists $args{token};
    $self->universal_req(
        DELETE => sprintf("/v2/addon/link/%s", delete $args{token}),
        undef,
        \%args,
        $cb
    );
}

sub delete_photo {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        DELETE => sprintf("/v2/user/%s/photo", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/action/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/dialog/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/externalPage/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/glance/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/webPanel/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_room_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/extension/webhook/%s", delete $args{room_id}, delete $args{key}),
        undef,
        \%args,
        $cb
    );
}

sub delete_session {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'access_token not defined'), return } if not exists $args{access_token};
    $self->universal_req(
        DELETE => sprintf("/v2/oauth/token/%s", delete $args{access_token}),
        undef,
        \%args,
        $cb
    );
}

sub delete_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        DELETE => sprintf("/v2/user/%s", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub delete_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),    return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'webhook_id not defined'), return } if not exists $args{webhook_id};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/webhook/%s", delete $args{room_id}, delete $args{webhook_id}),
        undef,
        \%args,
        $cb
    );
}

sub generate_token {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        POST => sprintf("/v2/oauth/token"),
        undef,
        \%args,
        $cb
    );
}

sub get_addon_capabilities_schema {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        GET => sprintf("/v2/capabilities/addon/schema"),
        \%args,
        undef,
        $cb
    );
}

sub get_all_emoticons {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        GET => sprintf("/v2/emoticon"),
        \%args,
        undef,
        $cb
    );
}

sub get_all_members {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/member", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_all_participants {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/participant", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_all_rooms {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        GET => sprintf("/v2/room"),
        \%args,
        undef,
        $cb
    );
}

sub get_all_users {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        GET => sprintf("/v2/user"),
        \%args,
        undef,
        $cb
    );
}

sub get_all_webhooks {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/webhook", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_auto_join_rooms {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        GET => sprintf("/v2/user/%s/preference/auto-join", delete $args{id}),
        \%args,
        undef,
        $cb
    );
}

sub get_capabilities {
    my $cb = pop;
    my ($self, %args) = @_;

    $self->universal_req(
        GET => sprintf("/v2/capabilities"),
        \%args,
        undef,
        $cb
    );
}

sub get_emoticon {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'emoticon_id not defined'), return } if not exists $args{emoticon_id};
    $self->universal_req(
        GET => sprintf("/v2/emoticon/%s", delete $args{emoticon_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/action/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/dialog/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/externalPage/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/glance/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/webPanel/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_global_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'key not defined'), return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/extension/webhook/%s", delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_group_avatar {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'group_id not defined'), return } if not exists $args{group_id};
    $self->universal_req(
        GET => sprintf("/v2/group/%s/avatar", delete $args{group_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_integration_installable_data {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'integration_id not defined'), return } if not exists $args{integration_id};
    do { $cb->(FAILED, undef, 'token not defined'),          return } if not exists $args{token};
    $self->universal_req(
        GET => sprintf("/v2/addon/%s/installable/%s", delete $args{integration_id}, delete $args{token}),
        \%args,
        undef,
        $cb
    );
}

sub get_photo {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),   return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'size not defined'), return } if not exists $args{size};
    $self->universal_req(
        GET => sprintf("/v2/user/%s/photo/%s", delete $args{id}, delete $args{size}),
        \%args,
        undef,
        $cb
    );
}

sub get_privatechat_message {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),         return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'message_id not defined'), return } if not exists $args{message_id};
    $self->universal_req(
        GET => sprintf("/v2/user/%s/history/%s", delete $args{id}, delete $args{message_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_room {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_action {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/action/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_dialog {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/dialog/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_external_page {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/externalPage/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_glance {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/glance/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_message {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),    return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'message_id not defined'), return } if not exists $args{message_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/history/%s", delete $args{room_id}, delete $args{message_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_statistics {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/statistics", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_web_panel {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/webPanel/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_room_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'key not defined'),     return } if not exists $args{key};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/extension/webhook/%s", delete $args{room_id}, delete $args{key}),
        \%args,
        undef,
        $cb
    );
}

sub get_session {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'access_token not defined'), return } if not exists $args{access_token};
    $self->universal_req(
        GET => sprintf("/v2/oauth/token/%s", delete $args{access_token}),
        \%args,
        undef,
        $cb
    );
}

sub get_webhook {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),    return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'webhook_id not defined'), return } if not exists $args{webhook_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/webhook/%s", delete $args{room_id}, delete $args{webhook_id}),
        \%args,
        undef,
        $cb
    );
}

sub group_statistics {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'group_id not defined'), return } if not exists $args{group_id};
    $self->universal_req(
        GET => sprintf("/v2/group/%s/statistics", delete $args{group_id}),
        \%args,
        undef,
        $cb
    );
}

sub invite_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'user_id not defined'), return } if not exists $args{user_id};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/invite/%s", delete $args{room_id}, delete $args{user_id}),
        undef,
        \%args,
        $cb
    );
}

sub invite_user_to_group {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'email not defined'), return } if not exists $args{email};
    do { $cb->(FAILED, undef, 'name not defined'),  return } if not exists $args{name};
    $self->universal_req(
        POST => sprintf("/v2/invite/user"),
        undef,
        \%args,
        $cb
    );
}

sub invoke_integration_link {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'token not defined'), return } if not exists $args{token};
    $self->universal_req(
        GET => sprintf("/v2/addon/link/%s", delete $args{token}),
        \%args,
        undef,
        $cb
    );
}

sub private_message_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),      return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'message not defined'), return } if not exists $args{message};
    $self->universal_req(
        POST => sprintf("/v2/user/%s/message", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub remove_member {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'user_id not defined'), return } if not exists $args{user_id};
    $self->universal_req(
        DELETE => sprintf("/v2/room/%s/member/%s", delete $args{room_id}, delete $args{user_id}),
        undef,
        \%args,
        $cb
    );
}

sub reply_to_message {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'),         return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'parentMessageId not defined'), return } if not exists $args{parentMessageId};
    do { $cb->(FAILED, undef, 'message not defined'),         return } if not exists $args{message};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/reply", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub room_addon_ui_update {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'glance not defined'),  return } if not exists $args{glance};
    $self->universal_req(
        POST => sprintf("/v2/addon/ui/room/%s", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub send_message {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'message not defined'), return } if not exists $args{message};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/message", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub send_room_notification {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'message not defined'), return } if not exists $args{message};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/notification", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub set_topic {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'topic not defined'),   return } if not exists $args{topic};
    $self->universal_req(
        PUT => sprintf("/v2/room/%s/topic", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub share_link_with_room {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'link not defined'),    return } if not exists $args{link};
    $self->universal_req(
        POST => sprintf("/v2/room/%s/share/link", delete $args{room_id}),
        undef,
        \%args,
        $cb
    );
}

sub share_link_with_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),   return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'link not defined'), return } if not exists $args{link};
    $self->universal_req(
        POST => sprintf("/v2/user/%s/share/link", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub update_group_avatar {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'group_id not defined'), return } if not exists $args{group_id};
    do { $cb->(FAILED, undef, 'avatar not defined'),   return } if not exists $args{avatar};
    $self->universal_req(
        PUT => sprintf("/v2/group/%s/avatar", delete $args{group_id}),
        undef,
        \%args,
        $cb
    );
}

sub update_photo {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),    return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'photo not defined'), return } if not exists $args{photo};
    $self->universal_req(
        PUT => sprintf("/v2/user/%s/photo", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub update_room {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'name not defined'),  return } if not exists $args{name};
    do { $cb->(FAILED, undef, 'topic not defined'), return } if not exists $args{topic};
    do { $cb->(FAILED, undef, 'owner not defined'), return } if not exists $args{owner};
    $self->universal_req(
        PUT => sprintf("/v2/room/{room_id_or_name}"),
        undef,
        \%args,
        $cb
    );
}

sub update_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'),           return } if not exists $args{id};
    do { $cb->(FAILED, undef, 'name not defined'),         return } if not exists $args{name};
    do { $cb->(FAILED, undef, 'mention_name not defined'), return } if not exists $args{mention_name};
    do { $cb->(FAILED, undef, 'email not defined'),        return } if not exists $args{email};
    $self->universal_req(
        PUT => sprintf("/v2/user/%s", delete $args{id}),
        undef,
        \%args,
        $cb
    );
}

sub user_addon_ui_update {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'user_id not defined'), return } if not exists $args{user_id};
    do { $cb->(FAILED, undef, 'glance not defined'),  return } if not exists $args{glance};
    $self->universal_req(
        POST => sprintf("/v2/addon/ui/user/%s", delete $args{user_id}),
        undef,
        \%args,
        $cb
    );
}

sub user_in_room_addon_ui_update {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    do { $cb->(FAILED, undef, 'user_id not defined'), return } if not exists $args{user_id};
    do { $cb->(FAILED, undef, 'glance not defined'),  return } if not exists $args{glance};
    $self->universal_req(
        POST => sprintf("/v2/addon/ui/room/%s/user/%s", delete $args{room_id}, delete $args{user_id}),
        undef,
        \%args,
        $cb
    );
}

sub view_group {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'group_id not defined'), return } if not exists $args{group_id};
    $self->universal_req(
        GET => sprintf("/v2/group/%s", delete $args{group_id}),
        \%args,
        undef,
        $cb
    );
}

sub view_privatechat_history {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        GET => sprintf("/v2/user/%s/history", delete $args{id}),
        \%args,
        undef,
        $cb
    );
}

sub view_recent_privatechat_history {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        GET => sprintf("/v2/user/%s/history/latest", delete $args{id}),
        \%args,
        undef,
        $cb
    );
}

sub view_recent_room_history {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/history/latest", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub view_room_history {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'room_id not defined'), return } if not exists $args{room_id};
    $self->universal_req(
        GET => sprintf("/v2/room/%s/history", delete $args{room_id}),
        \%args,
        undef,
        $cb
    );
}

sub view_user {
    my $cb = pop;
    my ($self, %args) = @_;
    do { $cb->(FAILED, undef, 'id not defined'), return } if not exists $args{id};
    $self->universal_req(
        GET => sprintf("/v2/user/%s", delete $args{id}),
        \%args,
        undef,
        $cb
    );
}

1;

=pod

=head1 NAME

AnyEvent::HipChat::Api::InjectMethods - hipchat api methods implementation

=head1 DESCRIPTION

This class contains hipchat method implementaions.

=head1 LIMITATIONS

This class is B<autogenerated>. Don't modify it by hand.
See B<generate.pl> for details.

=head2 METHODS


=over


=item add_member

PUT /v2/room/<room_id>/member/<user_id>

Adds a member to a private room and sends member's unavailable presence to all room members asynchronously.
Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item addon_ui_update

POST /v2/addon/ui

Push addon ui update to a groupAuthentication required. Accessible by group clients.


=item create_global_action

PUT /v2/extension/action/<key>

Create a global action.
Dynamically created actions have the following restrictions.
You can only create 10 global actionsYou cannot modify an action that was declared in the descriptorAuthentication required. Accessible by group clients.


=item create_global_dialog

PUT /v2/extension/dialog/<key>

Create a global dialog.
Dynamically created dialogs have the following restrictions.
You can only create 10 global dialogsYou cannot modify a dialog that was declared in the descriptorAuthentication required. Accessible by group clients.


=item create_global_external_page

PUT /v2/extension/externalPage/<key>

Create a global external page.
Dynamically created external pages have the following restrictions.
You can only create 10 global external pagesYou cannot modify an external page that was declared in the descriptorAuthentication required. Accessible by group clients.


=item create_global_glance

PUT /v2/extension/glance/<key>

Create a global glance.
Dynamically created glances have the following restrictions.
You can only create 10 global glancesYou cannot modify a glance that was declared in the descriptorAuthentication required. Accessible by group clients.


=item create_global_web_panel

PUT /v2/extension/webPanel/<key>

Create a global web panel.
Dynamically created web panel have the following restrictions.
You can only create 10 global web panelsYou cannot modify a web panel that was declared in the descriptorAuthentication required. Accessible by group clients.


=item create_global_webhook

PUT /v2/extension/webhook/<key>

Create a global webhook.
Dynamically created webhooks have the following restrictions.
You can only create 10 global webhooksYou cannot modify a webhook that was declared in the descriptorAuthentication required, with scope view_messages. Accessible by group clients.


=item create_integration_link

POST /v2/addon/link

Create a link target through which an integration can be reached through HipChat. A token will be returned which is used to access the linkAuthentication required. Accessible by group clients.


=item create_room

POST /v2/room

Creates a new room.
Authentication required, with scope manage_rooms. Accessible by group clients, users.


=item create_room_action

PUT /v2/room/<room_id>/extension/action/<key>

Create an action.
Dynamically created actions have the following restrictions.
You can only create 10 actions in a roomYou cannot modify an action that was declared in the descriptorAuthentication required. Accessible by group clients, room clients.


=item create_room_dialog

PUT /v2/room/<room_id>/extension/dialog/<key>

Create a dialog.
Dynamically created dialogs have the following restrictions.
You can only create 10 dialogs in a roomYou cannot modify a dialog that was declared in the descriptorAuthentication required. Accessible by group clients, room clients.


=item create_room_external_page

PUT /v2/room/<room_id>/extension/externalPage/<key>

Create an external page.
Dynamically created external pages have the following restrictions.
You can only create 10 external pages in a roomYou cannot modify an external page that was declared in the descriptorAuthentication required. Accessible by group clients, room clients.


=item create_room_glance

PUT /v2/room/<room_id>/extension/glance/<key>

Create a glance.
Dynamically created glances have the following restrictions.
You can only create 10 glances in a roomYou cannot modify a glance that was declared in the descriptorAuthentication required. Accessible by group clients, room clients.


=item create_room_web_panel

PUT /v2/room/<room_id>/extension/webPanel/<key>

Create a web panel.
Dynamically created web panels have the following restrictions.
You can only create 10 web panels in a roomYou cannot modify a web panel that was declared in the descriptorAuthentication required. Accessible by group clients, room clients.


=item create_room_webhook

PUT /v2/room/<room_id>/extension/webhook/<key>

Create a webhook.
Dynamically created webhooks have the following restrictions.
You can only create 10 webhooks in a roomYou cannot modify a webhook that was declared in the descriptorAuthentication required, with scope view_messages. Accessible by group clients, room clients.


=item create_user

POST /v2/user

Creates a new user.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item create_webhook

POST /v2/room/<room_id>/webhook

Deprecated: Please use Create room webhook instead, which preserves extensions across add-on updates and requires only the view_messages scope.
Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item delete_global_action

DELETE /v2/extension/action/<key>

Delete a global action. You cannot delete an action which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_global_dialog

DELETE /v2/extension/dialog/<key>

Delete a global dialog. You cannot delete a dialog which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_global_external_page

DELETE /v2/extension/externalPage/<key>

Delete a global external page. You cannot delete an external page which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_global_glance

DELETE /v2/extension/glance/<key>

Delete a global glance. You cannot delete a glance which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_global_web_panel

DELETE /v2/extension/webPanel/<key>

Delete a global web panel. You cannot delete a web panel which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_global_webhook

DELETE /v2/extension/webhook/<key>

Delete a global webhook. You cannot delete a webhook which was declared in the descriptor.
Authentication required. Accessible by group clients.


=item delete_group_avatar

DELETE /v2/group/<group_id>/avatar

Delete group avatar.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item delete_integration_link

DELETE /v2/addon/link/<token>

Delete a link endpoint by its tokenAuthentication required. Accessible by group clients.


=item delete_photo

DELETE /v2/user/<id>/photo

Delete a user photo. A guest cannot be updated.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item delete_room

DELETE /v2/room/<room_id>

Deletes a room and kicks the current participants.
Authentication required, with scope manage_rooms. Accessible by group clients, users.


=item delete_room_action

DELETE /v2/room/<room_id>/extension/action/<key>

Delete an action. You cannot delete an action that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_room_dialog

DELETE /v2/room/<room_id>/extension/dialog/<key>

Delete a dialog. You cannot delete a dialog that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_room_external_page

DELETE /v2/room/<room_id>/extension/externalPage/<key>

Delete an external page. You cannot delete an external page that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_room_glance

DELETE /v2/room/<room_id>/extension/glance/<key>

Delete a glance. You cannot delete a glance that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_room_web_panel

DELETE /v2/room/<room_id>/extension/webPanel/<key>

Delete a web panel. You cannot delete a web panel that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_room_webhook

DELETE /v2/room/<room_id>/extension/webhook/<key>

Delete a webhook. You cannot delete a webhook that was declared in the descriptor.
Authentication required. Accessible by group clients, room clients.


=item delete_session

DELETE /v2/oauth/token/<access_token>

Deletes the OAuth session via its associated access_tokenAuthentication required. Accessible by group clients, room clients, users.


=item delete_user

DELETE /v2/user/<id>

Delete a user.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item delete_webhook

DELETE /v2/room/<room_id>/webhook/<webhook_id>

Deprecated: Please use Delete room webhook instead.
Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item generate_token

POST /v2/oauth/token

Gets an OAuth token for requested grant type. Grant types supported.
personalclient_credentialspasswordrefresh_tokenauthorization_codeAuthentication required. Accessible by oauth clients.


=item get_addon_capabilities_schema

GET /v2/capabilities/addon/schema

Gets the addon capabilities descriptor schema Authentication not required. 


=item get_all_emoticons

GET /v2/emoticon

Gets all emoticons for the current groupAuthentication required, with scope view_group. Accessible by group clients, room clients, users.


=item get_all_members

GET /v2/room/<room_id>/member

Gets all members for this private room.
Authentication required, with scope view_room. Accessible by group clients, room clients, users.


=item get_all_participants

GET /v2/room/<room_id>/participant

Gets all participants in this room.
Authentication required, with scope view_room. Accessible by group clients, room clients, users.


=item get_all_rooms

GET /v2/room

List non-archived rooms for this group.
Authentication required, with scope view_group or view_room. Accessible by group clients, users.


=item get_all_users

GET /v2/user

List all users in the group.
Authentication required, with scope view_group. Accessible by group clients, users.


=item get_all_webhooks

GET /v2/room/<room_id>/webhook

Gets all webhooks for this roomAuthentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item get_auto_join_rooms

GET /v2/user/<id>/preference/auto-join

Get the list of rooms a user joins when they log in.
Authentication required, with scope view_group. Accessible by group clients, users.


=item get_capabilities

GET /v2/capabilities

Gets the capabilities descriptor for HipChat Authentication not required. 


=item get_emoticon

GET /v2/emoticon/<emoticon_id>

Get emoticon details.
Authentication required, with scope view_group. Accessible by group clients, room clients, users.


=item get_global_action

GET /v2/extension/action/<key>

Retrieve a global action.
Authentication required. Accessible by group clients.


=item get_global_dialog

GET /v2/extension/dialog/<key>

Retrieve a global dialog.
Authentication required. Accessible by group clients.


=item get_global_external_page

GET /v2/extension/externalPage/<key>

Retrieve a global external page.
Authentication required. Accessible by group clients.


=item get_global_glance

GET /v2/extension/glance/<key>

Retrieve a global glance.
Authentication required. Accessible by group clients.


=item get_global_web_panel

GET /v2/extension/webPanel/<key>

Retrieve a global web panel.
Authentication required. Accessible by group clients.


=item get_global_webhook

GET /v2/extension/webhook/<key>

Retrieve a global webhook.
Authentication required. Accessible by group clients.


=item get_group_avatar

GET /v2/group/<group_id>/avatar

Gets a group avatarAuthentication required, with scope view_group. Accessible by group clients, users.


=item get_integration_installable_data

GET /v2/addon/<integration_id>/installable/<token>

Get integration installable data. This resource is only useful for integration installations that provide the integration with the installable data URL (this URL). Will be deleted after first access. Authentication not required. 


=item get_photo

GET /v2/user/<id>/photo/<size>

Gets a user photoAuthentication required, with scope view_group. Accessible by group clients, users.


=item get_privatechat_message

GET /v2/user/<id>/history/<message_id>

Fetch one specific message by idAuthentication required, with scope view_messages. Accessible by group clients, users.


=item get_room

GET /v2/room/<room_id>

Get room details.
Authentication required, with scope view_group or view_room. Accessible by group clients, room clients, users.


=item get_room_action

GET /v2/room/<room_id>/extension/action/<key>

Retrieve an action.
Authentication required. Accessible by group clients, room clients.


=item get_room_dialog

GET /v2/room/<room_id>/extension/dialog/<key>

Retrieve a dialog.
Authentication required. Accessible by group clients, room clients.


=item get_room_external_page

GET /v2/room/<room_id>/extension/externalPage/<key>

Retrieve an external page.
Authentication required. Accessible by group clients, room clients.


=item get_room_glance

GET /v2/room/<room_id>/extension/glance/<key>

Retrieve a glance/Authentication required. Accessible by group clients, room clients.


=item get_room_message

GET /v2/room/<room_id>/history/<message_id>

Fetch one specific message by idAuthentication required, with scope view_messages. Accessible by group clients, room clients, users.


=item get_room_statistics

GET /v2/room/<room_id>/statistics

Fetch statistics for this room.
Authentication required, with scope view_group or view_room. Accessible by group clients, room clients, users.


=item get_room_web_panel

GET /v2/room/<room_id>/extension/webPanel/<key>

Retrieve a web panel.
Authentication required. Accessible by group clients, room clients.


=item get_room_webhook

GET /v2/room/<room_id>/extension/webhook/<key>

Retrieve a webhook.
Authentication required. Accessible by group clients, room clients.


=item get_session

GET /v2/oauth/token/<access_token>

Gets the OAuth session via its associated access_tokenAuthentication required. Accessible by group clients, room clients, users.


=item get_webhook

GET /v2/room/<room_id>/webhook/<webhook_id>

Deprecated: Please use Get room webhook instead.
Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item group_statistics

GET /v2/group/<group_id>/statistics

Get a group's details.
Authentication required, with scope view_group. Accessible by group clients, users.


=item invite_user

POST /v2/room/<room_id>/invite/<user_id>

Invite a user to a public room. This API can only be called using a user token which can be obtained through.
Your own Personal API TokenGenerating a token using one of the following grant_types: authorization_code -- This is the authorization step of a 3-legged OAuth 2 flowrefresh_token -- When a 3-legged OAuth token expires, you can request a new one through this grant_typepassword -- This grant_type allows you to request a user token by providing a username/passwordAuthentication required, with scope admin_room. Accessible by users.


=item invite_user_to_group

POST /v2/invite/user

Invites a user to join a group.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item invoke_integration_link

GET /v2/addon/link/<token>

Access an integration link. This provides a GET endpoint to reach the link. Upon receiving a request, a JSON object is POSTed to the integration at the link it has registered. The JSON object contains the client_id for whom the link was registered and the token used to reach the link.
This endpoint expects the integration to reply with a JSON response containing a redirect location, to which it will then redirect the response. There is no ability to send content from the integration. Authentication not required. 


=item private_message_user

POST /v2/user/<id>/message

Sends a user a private message. This API can only be called using a user token which can be obtained through.
Your own Personal API TokenGenerating a token using one of the following grant_types: authorization_code -- This is the authorization step of a 3-legged OAuth 2 flowrefresh_token -- When a 3-legged OAuth token expires, you can request a new one through this grant_typepassword -- This grant_type allows you to request a user token by providing a username/passwordThe message can also be sent as text/plainAuthentication required, with scope send_message. Accessible by users.


=item remove_member

DELETE /v2/room/<room_id>/member/<user_id>

Removes a member from a private room.
Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item reply_to_message

POST /v2/room/<room_id>/reply

Reply to a message in a room.
Authentication required, with scope send_message. Accessible by users.


=item room_addon_ui_update

POST /v2/addon/ui/room/<room_id>

Push addon ui update to a roomAuthentication required. Accessible by group clients, room clients.


=item send_message

POST /v2/room/<room_id>/message

Send a message to a room.
Authentication required, with scope send_message. Accessible by users.


=item send_room_notification

POST /v2/room/<room_id>/notification

Send a message to a room. This resource accepts three different content-types.
application/x-www-form-urlencoded - If you send as a form-encoded POST, the form fields will be mapped to their corresponding JSON properties.
text/plain - If you send with the text/plain content-type, the payload will be treated as a plain text message with a default background color of yellow and the notify flag set to false.
text/html - If you send with the text/html content-type, the payload will be treated as an HTML message with a default background color of yellow and the notify flag set to false.
application/json - If you send with the application/json content-type, the payload will be treated as JSON with the expected format described in the Requested Body section below.
Authentication required, with scope send_notification. Accessible by group clients, room clients, users.


=item set_topic

PUT /v2/room/<room_id>/topic

Set a room's topic. Useful for displaying statistics, important links, server status, you name it!Authentication required, with scope admin_room. Accessible by group clients, room clients, users.


=item share_link_with_room

POST /v2/room/<room_id>/share/link

Share a link with the room.
Authentication required, with scope send_message. Accessible by users.


=item share_link_with_user

POST /v2/user/<id>/share/link

Share a link with another user.
Authentication required, with scope send_message. Accessible by users.


=item update_group_avatar

PUT /v2/group/<group_id>/avatar

Update a group avatar.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item update_photo

PUT /v2/user/<id>/photo

Update a user photo. A guest cannot be updated.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item update_room

PUT /v2/room/{room_id_or_name}

Updates a room.
Authentication required, with scope admin_room. Accessible by group clients, users.


=item update_user

PUT /v2/user/<id>

Update a user. A guest cannot be updated.
Authentication required, with scope admin_group. Accessible by group clients, users.


=item user_addon_ui_update

POST /v2/addon/ui/user/<user_id>

Push addon ui update to a userAuthentication required. Accessible by group clients.


=item user_in_room_addon_ui_update

POST /v2/addon/ui/room/<room_id>/user/<user_id>

Push addon ui update to a single user in a roomAuthentication required. Accessible by group clients, room clients.


=item view_group

GET /v2/group/<group_id>

Get a group's details.
Authentication required, with scope view_group. Accessible by group clients, users.


=item view_privatechat_history

GET /v2/user/<id>/history

Fetch chat history for the 1.
1 chat with the user identified by idoremail.
NOTE.
According to ISO-8601 the plus sign '+' is used for specifying the time offset from UTC. But '+' in a GET query is recognized as a whitespace by the API HTTP-server. For specifying the time offset, replace the character by '%2B' in the GET query.
To fetch the history before '2015-06-16T15.
33.
30+01.
00' you would use the query 'http://hipchat.
com/v2/user/513/history?date=2015-06-16T15.
33.
30%2B01.
00' (plus is replaced by '%2B').It's possible to specify the date using UNIX timestamp format: 'http://hipchat.
com/v2/user/513/history?date=1434465210'.Same thing for the end-date parameter.
Authentication required, with scope view_messages. Accessible by users.


=item view_recent_privatechat_history

GET /v2/user/<id>/history/latest

Fetch latest chat history for the 1.
1 chat with the user identified by idoremail.
Authentication required, with scope view_messages. Accessible by users.


=item view_recent_room_history

GET /v2/room/<room_id>/history/latest

Fetch latest chat history for this room.
Authentication required, with scope view_messages. Accessible by group clients, room clients, users.


=item view_room_history

GET /v2/room/<room_id>/history

Fetch chat history for this room.
NOTE.
According to ISO-8601 the plus sign '+' is used for specifying the time offset from UTC. But '+' in a GET query is recognized as a whitespace by the API HTTP-server. For specifying the time offset, replace the character by '%2B' in the GET query.
To fetch the history before '2015-06-16T15.
33.
30+01.
00' you would use the query 'http://hipchat.
com/v2/room/513/history?date=2015-06-16T15.
33.
30%2B01.
00' (plus is replaced by '%2B').It's possible to specify the date using UNIX timestamp format: 'http://hipchat.
com/v2/room/513/history?date=1434465210'.Same thing for the end-date parameter.
Authentication required, with scope view_group or view_messages. Accessible by group clients, room clients, users.


=item view_user

GET /v2/user/<id>

Get a user's details.
Authentication required, with scope view_group. Accessible by group clients, users.


=back



=head1 SEE ALSO

L<AnyEvent::HipChat::Api>, L<AnyEvent::HipChat>

=cut

